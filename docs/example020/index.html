<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<title>example020.stl</title>
		<script type="importmap">{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js","three/addons/":"https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/"}}</script>
		<script>
			window.STL_URL = new URL("example020.stl", window.location.href);
		</script>
		<link rel="stylesheet" href="https://www.w3.org/StyleSheets/Core/Midnight">
		<style>
			body {
				margin: 0;
				padding: 0;
				display: flex;
				height: 100vh;
			}

			pre {
				padding: 0.5rem;
				overflow-x: auto;
				background-color: hsla(0, 0%, 100%, 0.1);
			}

			#info {
				width: 40%;
				padding: 0 2rem;
				box-sizing: border-box;
				overflow: auto;

				& h1 {
					font-size: 3rem;
					margin: 1rem 0;
				}

				& table tr td:first-child {
					text-align: right;
					padding-right: 5px;
				}
			}

			#viewer {
				flex: 1;
				position: relative;
				overflow: hidden;
				background: radial-gradient(120% 80% at 50% 10%,
						rgba(0, 0, 0, 0.15),
						#0000 60%),
					linear-gradient(#000, #184284 70%);
				perspective: 1200px;
			}

			#viewer::after,
			#viewer::before {
				position: absolute;
				z-index: 0;
				/* baseline */
			}

			#viewer canvas {
				position: relative;
				z-index: 100;
				/* ensure STL canvas is above background */
			}

			/* grid floor */
			#viewer::before {
				content: "";
				z-index: 2;
				left: -50%;
				right: -50%;
				bottom: 0;
				height: 100%;
				transform-origin: center bottom;
				transform: rotateX(55deg) translateZ(-100px);
				background: repeating-linear-gradient(to bottom,
						rgba(255, 255, 255, 0.05) 0 40px,
						rgba(255, 255, 255, 0.15) 40px 42px),
					repeating-linear-gradient(to right,
						rgba(255, 255, 255, 0.05) 0 80px,
						rgba(255, 255, 255, 0.15) 80px 82px);
				background-color: #000;
			}

			/* horizon glow */
			#viewer::after {
				content: "";
				z-index: 1;
				left: 0;
				right: 0;
				bottom: 50%;
				height: 0;
				background: linear-gradient(90deg, transparent, #74f5ff, transparent);
				box-shadow:
					0 0 12px 2px #74f5ff,
					0 0 28px 6px #74f5ff,
					0 0 60px 12px #74f5ff;
			}
		</style>
	</head>

	<body>
		<!-- Details & Code / Left Side -->
		<div id="info">
			<h1>example020.scad</h1>
			<table>
			<tr>
				<td>
				<strong>SCAD</strong>
				</td>
				<td>./models/example020.scad</td>
			</tr>
			<tr>
				<td>
				<strong>STL</strong>
				</td>
				<td>
				<a href="">example020.stl</a>
				</td>
			</tr>
			</table>
			<h4>File Content</h4>
			<pre>
module screw(type = 2, r1 = 15, r2 = 20, n = 7, h = 100, t = 8)
{
  linear_extrude(height = h, twist = 360*t/n, convexity = t)
  difference() {
    circle(r2);
    for (i = [0:n-1]) {
        if (type == 1) rotate(i*360/n) polygon([
            [ 2*r2, 0 ],
            [ r2, 0 ],
            [ r1*cos(180/n), r1*sin(180/n) ],
            [ r2*cos(360/n), r2*sin(360/n) ],
            [ 2*r2*cos(360/n), 2*r2*sin(360/n) ],
        ]);
        if (type == 2) rotate(i*360/n) polygon([
            [ 2*r2, 0 ],
            [ r2, 0 ],
            [ r1*cos(90/n), r1*sin(90/n) ],
            [ r1*cos(180/n), r1*sin(180/n) ],
            [ r2*cos(270/n), r2*sin(270/n) ],
            [ 2*r2*cos(270/n), 2*r2*sin(270/n) ],
        ]);
    }
  }
}

module nut(type = 2, r1 = 16, r2 = 21, r3 = 30, s = 6, n = 7, h = 100/5, t = 8/5)
{
  difference() {
    cylinder($fn = s, r = r3, h = h);
    translate([ 0, 0, -h/2 ]) screw(type, r1, r2, n, h*2, t*2);
  }
}

module spring(r1 = 100, r2 = 10, h = 100, hr = 12)
{
  stepsize = 1/16;
  module segment(i1, i2) {
    alpha1 = i1 * 360*r2/hr;
    alpha2 = i2 * 360*r2/hr;
    len1 = sin(acos(i1*2-1))*r2;
    len2 = sin(acos(i2*2-1))*r2;
    if (len1 < 0.01) {
      polygon([
        [ cos(alpha1)*r1, sin(alpha1)*r1 ],
        [ cos(alpha2)*(r1-len2), sin(alpha2)*(r1-len2) ],
        [ cos(alpha2)*(r1+len2), sin(alpha2)*(r1+len2) ]
      ]);
    }
    if (len2 < 0.01) {
      polygon([
        [ cos(alpha1)*(r1+len1), sin(alpha1)*(r1+len1) ],
        [ cos(alpha1)*(r1-len1), sin(alpha1)*(r1-len1) ],
        [ cos(alpha2)*r1, sin(alpha2)*r1 ],
      ]);
    }
    if (len1 >= 0.01 && len2 >= 0.01) {
      polygon([
        [ cos(alpha1)*(r1+len1), sin(alpha1)*(r1+len1) ],
        [ cos(alpha1)*(r1-len1), sin(alpha1)*(r1-len1) ],
        [ cos(alpha2)*(r1-len2), sin(alpha2)*(r1-len2) ],
        [ cos(alpha2)*(r1+len2), sin(alpha2)*(r1+len2) ]
      ]);
    }
  }
  linear_extrude(height = 100, twist = 180*h/hr,
                 $fn = (hr/r2)/stepsize, convexity = 5) {
    for (i = [ stepsize : stepsize : 1+stepsize/2 ])
      segment(i-stepsize, min(i, 1));
  }
}

echo(version=version());
translate([ -30, 0, 0 ]) screw();

translate([ 30, 0, 0 ]) nut();

spring();

// Written by Clifford Wolf <clifford@clifford.at> and Marius
// Kintel <marius@kintel.net>
//
// To the extent possible under law, the author(s) have dedicated all
// copyright and related and neighboring rights to this software to the
// public domain worldwide. This software is distributed without any
// warranty.
//
// You should have received a copy of the CC0 Public Domain
// Dedication along with this software.
// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
</pre>
		</div>

		<!-- Container for STL / Right Side -->
		<div id="viewer"></div>

		<!-- Three.js Renderer -->
		<script type="module">
			import * as THREE from 'three';
			import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
			import {STLLoader} from 'three/addons/loaders/STLLoader.js';
			import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.21/+esm';

			const loader = new STLLoader();
			const container = document.getElementById('viewer');

			let renderer, camera, spotLight, scene, controls;

			function setupRenderer() {
				renderer = new THREE.WebGLRenderer({alpha: true, antialias: true});
				renderer.setSize(container.clientWidth, container.clientHeight);
				renderer.setClearColor(0xffffff, 0);
				container.appendChild(renderer.domElement);
			}

			/**
			 * @param initialCamera#x,y,z
			 */
			function setupCameraAndControls({x, y, z}) {
				const fov = 60;
				const aspect = container.clientWidth / container.clientHeight;
				camera = new THREE.PerspectiveCamera(fov, aspect, 0.1, 1000);
				camera
					.position
					.set(x, y, z);
				controls = new OrbitControls(camera, renderer.domElement);
			}

			/**
			 * @param initialSpotlight#x,y,z
			 */
			function setupScene({x, y, z}) {
				scene = new THREE.Scene();
				// scene.background = new THREE.Color(0x000000);

				const roomLight = new THREE.AmbientLight(0x888888);
				scene.add(roomLight);

				spotLight = new THREE.DirectionalLight(0xffffff, 1);
				spotLight.position.set(x, y, z);
				scene.add(spotLight);
			}

			function renderScene() {
				renderer.render(scene, camera);
			}

			function loadSTL(stlUrl) {
				const material = new THREE.MeshPhongMaterial({color: 0x5588ff});

				loader.load(stlUrl, (geometry) => {
					const center = new THREE.Vector3();

					geometry.computeBoundingBox();
					geometry
						.boundingBox
						.getCenter(center)
						.negate();
					geometry.translate(center.x, center.y, center.z);

					const mesh = new THREE.Mesh(geometry, material);

					scene.add(mesh);
				});
			}

			function setupResizeHandler() {
				window.addEventListener('resize', () => {
					const {clientHeight, clientWidth} = container;
					renderer.setSize(clientWidth, clientHeight);
					camera.aspect = clientWidth / clientHeight;
					camera.updateProjectionMatrix();
				});
			}

			function animate() {
				requestAnimationFrame(animate);
				controls.update();
				renderScene();
			}

			function setupGUI(initialState) {
				const {lightPos, cameraPos} = initialState;
				const gui = new GUI();
				gui.onChange(event => {
					console.log(gui.save());
				})

				const lightingFolder = gui
					.addFolder("Lighting")
					.onChange((event) => {
						spotLight.position.x = event.object.x;
						spotLight.position.y = event.object.y;
						spotLight.position.z = event.object.z;
					});
				lightingFolder.add(lightPos, "x", -500, 500, 1);
				lightingFolder.add(lightPos, "y", -500, 500, 1);
				lightingFolder.add(lightPos, "z", -500, 500, 1);

				const cameraFolder = gui
					.addFolder("Camera")
					.onChange((event) => {
						camera.position.x = event.object.x;
						camera.position.y = event.object.y;
						camera.position.z = event.object.z;
						camera.zoom = event.object.zoom;
						camera.updateProjectionMatrix();
					});
				cameraFolder.add(cameraPos, "x", -90, 90, 1);
				cameraFolder.add(cameraPos, "y", -90, 90, 1);
				cameraFolder.add(cameraPos, "z", -90, 90, 1);
				cameraFolder.add(cameraPos, "zoom", 1, 20, .5);
			}

			function init() {
				const initialState = {
					lightPos: {
						x: 20,
						y: 50,
						z: 100
					},
					cameraPos: {
						x: 30,
						y: 30,
						z: 30,
						zoom: 1
					}
				};
				setupRenderer();
				setupScene(initialState.lightPos);
				setupCameraAndControls(initialState.cameraPos);
				setupResizeHandler();
				setupGUI(initialState);
				loadSTL(window.STL_URL); // STL_URL is defined in the <head>
				animate();
			}

			init();
		</script>
	</body>
</html>
